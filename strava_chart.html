<!DOCTYPE html>
<html>
<head>
    <title>Athlete Activities Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f4f4f4;
            margin: 0;
        }
        .chart-container {
            width: 90%;
            max-width: 1200px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .upload-btn {
            display: inline-block;
            background-color: #fc4c02;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 12px 16px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 16px;
        }
        .upload-btn:hover {
            background-color: #e04302;
        }
        .legend-toggles {
            margin: 8px 0 0 0;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        .legend-toggles label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        .legend-swatch {
            width: 14px;
            height: 4px;
            border-radius: 2px;
            display: inline-block;
        }
        .secondary-btn {
            display: inline-block;
            background-color: #ffffff;
            color: #333;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 12px 16px;
            font-size: 16px;
            cursor: pointer;
            margin-left: 8px;
            margin-bottom: 16px;
        }
        .secondary-btn:hover {
            background-color: #f6f6f6;
        }
        .api-input-group {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        .api-input-group label {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }
        .api-input-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            width: 120px;
        }
        .api-input-group input[type="text"] {
            width: 300px;
        }
        .loading {
            display: none;
            color: #666;
            font-size: 14px;
            margin-left: 12px;
        }
        .error-message {
            display: none;
            color: #d32f2f;
            font-size: 14px;
            margin-top: 8px;
            padding: 8px 12px;
            background-color: #ffebee;
            border-radius: 6px;
            border-left: 3px solid #d32f2f;
        }
        .coming-soon {
            display: none;
            height: 60vh;
            min-height: 360px;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: #666;
        }
        .location-table-container {
            margin-top: 24px;
        }
        .location-table-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #333;
        }
        .location-table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            background-color: #fff;
        }
        .location-table thead {
            background: linear-gradient(135deg, #fc4c02 0%, #e04302 100%);
            color: #fff;
        }
        .location-table th {
            padding: 14px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.5px;
        }
        .location-table tbody tr {
            transition: background-color 0.2s ease;
        }
        .location-table tbody tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .location-table tbody tr:hover {
            background-color: #e8f4f8;
            cursor: pointer;
        }
        .location-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 14px;
        }
        .location-table td:first-child {
            font-weight: 500;
            color: #333;
            max-width: 300px;
        }
        .location-table td:nth-child(2) {
            font-weight: 600;
            color: #fc4c02;
            width: 80px;
        }
        .location-map-cell {
            width: 200px;
            height: 120px;
            padding: 0 !important;
        }
        .location-map-cell > div {
            width: 100%;
            height: 100%;
            border-radius: 4px;
            overflow: hidden;
        }

        /* Modal styles for interactive map */
        .map-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.35);
            justify-content: center;
            align-items: center;
        }
        .map-modal-content {
            background: #fff;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 90vw;
            max-height: 85vh;
            position: relative;
            overflow: hidden;
        }
        .map-modal-close {
            position: absolute;
            right: 18px;
            top: 8px;
            font-size: 30px;
            color: #888;
            cursor: pointer;
            z-index: 10;
        }
        .map-modal-close:hover {
            color: #fc4c02;
        }
        #modalMapHeader {
            font-size: 18px;
            padding: 18px 20px 0 20px;
            font-weight: 600;
            color: #333;
        }
        #modalMap {
            width: 100%;
            height: 60vh;
            margin: 0 0 18px 0;
            border-radius: 0 0 12px 12px;
        }
    </style>
</head>
<body>
    <div class="chart-container">
        <button id="uploadBtn" class="upload-btn">Upload JSON</button>
        <div class="api-input-group">
            <button id="callApiBtn" class="secondary-btn">Call Strava API</button>
            <label for="numActivities">Number of activities:</label>
            <input type="number" id="numActivities" value="10" min="1">
            <label for="authToken">Auth Token:</label>
            <input type="text" id="authToken" value="edd80a3502e056835e0d483853bd15f11d0f1495" placeholder="Bearer token">
            <span id="loading" class="loading">Loading...</span>
        </div>
        <div class="api-input-group" style="margin-top: 12px;">
            <button id="oauthBtn" class="upload-btn" style="margin-bottom: 0;">Connect with Strava (OAuth)</button>
            <button id="useStoredTokenBtn" class="secondary-btn" style="margin-bottom: 0;">Use Stored Token</button>
            <span id="oauthLoading" class="loading">Loading...</span>
        </div>
        <div id="errorMessage" class="error-message"></div>
        <input type="file" id="jsonFileInput" accept="application/json" style="display:none;">
        <div id="sportControls" class="legend-toggles"></div>
        <canvas id="activitiesChart"></canvas>
        <div id="speedPowerControls" class="legend-toggles"></div>
        <canvas id="distanceChart" style="margin-top: 24px;"></canvas>
        <div id="distanceElevationControls" class="legend-toggles"></div>
        <canvas id="heartRateChart" style="margin-top: 24px;"></canvas>
        <div id="heartRateControls" class="legend-toggles"></div>
        <div id="locationChart" style="margin-top: 24px;"></div>
        <div id="comingSoon" class="coming-soon" aria-hidden="true">
            <svg width="96" height="96" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M12 2L2 7l10 5 10-5-10-5Zm0 7L2 4v13l10 5 10-5V4l-10 5Z" fill="#e0e0e0"/>
            </svg>
            <div style="margin-top:12px; font-size:18px; color:#444;">Coming soon</div>
        </div>
    </div>

    <!-- Interactive Map Modal -->
    <div id="mapModal" class="map-modal" aria-hidden="true">
        <div class="map-modal-content">
            <span class="map-modal-close" aria-label="Close">&times;</span>
            <div id="modalMapHeader"></div>
            <div id="modalMap"></div>
        </div>
    </div>

    <script>
        function renderChart(activitiesData) {
            // Filter to Ride and VirtualRide only, then sort ascending by date
            const allowedSports = new Set(['Ride', 'VirtualRide']);
            const filtered = activitiesData.filter(a => allowedSports.has(a.sport_type));
            const sortedActivities = [...filtered].sort((a, b) => {
                return new Date(a.start_date_local) - new Date(b.start_date_local);
            });

            if (!sortedActivities.length) {
                const container = document.querySelector('.chart-container');
                const infoEl = document.createElement('div');
                infoEl.textContent = 'No Ride or VirtualRide activities to display.';
                infoEl.style.marginTop = '12px';
                container.appendChild(infoEl);
                return;
            }

            const labels = sortedActivities.map(activity => {
            const date = new Date(activity.start_date_local);
                return date.toLocaleDateString();
            });

            const data = sortedActivities.map(activity => {
                return Number((activity.average_speed * 3.6).toFixed(2));
            });

            const avgWatts = sortedActivities.map(activity => {
                return (typeof activity.average_watts === 'number') ? Math.round(activity.average_watts) : null;
            });

            // Build sport filter toggles
            buildSportToggles();

            function buildSportToggles() {
                const container = document.getElementById('sportControls');
                container.innerHTML = '';
                const config = [
                    { key: 'Ride', color: '#2e7d32', label: 'Ride' },
                    { key: 'VirtualRide', color: '#1e88e5', label: 'VirtualRide' }
                ];
                const state = { Ride: true, VirtualRide: true };
                const counts = {
                    Ride: activitiesData.filter(a => a.sport_type === 'Ride').length,
                    VirtualRide: activitiesData.filter(a => a.sport_type === 'VirtualRide').length
                };

                config.forEach(({ key, color, label }) => {
                    const el = document.createElement('label');
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = true;
                    cb.addEventListener('change', () => {
                        state[key] = cb.checked;
                        // Recompute visible set and re-render all charts
                        const visible = activitiesData.filter(a => (a.sport_type in state ? state[a.sport_type] : false));
                        // Prevent empty allowedSports filtering; default both off -> empty
                        rerenderAll(visible);
                    });
                    const sw = document.createElement('span');
                    sw.className = 'legend-swatch';
                    sw.style.backgroundColor = color;
                    const txt = document.createElement('span');
                    txt.textContent = `${label} (${counts[key]})`;
                    el.appendChild(cb);
                    el.appendChild(sw);
                    el.appendChild(txt);
                    container.appendChild(el);
                });

                // Initial render with both on
                rerenderAll(activitiesData);
            }

            function rerenderAll(currentData) {
                // Filter and sort current set
                const allowed = new Set(['Ride', 'VirtualRide']);
                const filteredNow = currentData.filter(a => allowed.has(a.sport_type));
                const sortedNow = [...filteredNow].sort((a, b) => new Date(a.start_date_local) - new Date(b.start_date_local));

                drawCharts(sortedNow);
            }

            // Keep references to charts so we can destroy them before re-creating
            window.speedPowerChart = window.speedPowerChart || null;
            window.distanceElevationChart = window.distanceElevationChart || null;
            window.heartRateChart = window.heartRateChart || null;

            // Helper to format dates like: Wed 1 Jun
            function formatDateLabel(dateObj) {
                const parts = new Intl.DateTimeFormat('en-GB', {
                    weekday: 'short',
                    day: 'numeric',
                    month: 'short'
                }).formatToParts(dateObj);
                const map = Object.fromEntries(parts.map(p => [p.type, p.value]));
                return `${map.weekday} ${map.day} ${map.month}`;
            }

            // Helper to format moving_time seconds to "xhrs ymins"
            function formatMovingTime(totalSeconds) {
                if (typeof totalSeconds !== 'number' || !isFinite(totalSeconds)) return '';
                const totalMinutes = Math.round(totalSeconds / 60);
                const hours = Math.floor(totalMinutes / 60);
                const mins = totalMinutes % 60;
                if (hours > 0 && mins > 0) return `${hours}hrs ${mins}mins`;
                if (hours > 0) return `${hours}hrs`;
                return `${mins}mins`;
            }

            // Helper to format timezone to simplified location
            function formatTimezone(tz) {
                if (!tz || typeof tz !== 'string') return 'Unknown';
                // Extract the location part after GMT offset
                const match = tz.match(/\(.*?\)\s*(.+)/);
                if (!match) return tz;
                const location = match[1];
                // Split by '/' and format as "City, Country"
                // Note: timezone format is "Country/City" so we need to swap
                const parts = location.split('/');
                if (parts.length === 2) {
                    const country = parts[0].replace(/_/g, ' ');
                    const city = parts[1].replace(/_/g, ' ');
                    return `${city}, ${country}`;
                }
                return location;
            }

            function drawCharts(sortedActivities) {
                if (!sortedActivities.length) {
                    const container = document.querySelector('.chart-container');
                    const infoEl = document.createElement('div');
                    infoEl.textContent = 'No activities to display with current filters.';
                    infoEl.style.marginTop = '12px';
                    container.appendChild(infoEl);
                    return;
                }
                const chartContainer = document.querySelector('.chart-container');
                // Remove previous info messages if any
                const infos = chartContainer.querySelectorAll('.info-msg');
                infos.forEach(n => n.remove());

                // Compute new series
                const labels = sortedActivities.map(activity => formatDateLabel(new Date(activity.start_date_local)));
                const data = sortedActivities.map(activity => Number((activity.average_speed * 3.6).toFixed(2)));
                const distanceKm = sortedActivities.map(activity => Number((activity.distance / 1000).toFixed(2)));
                const elevationM = sortedActivities.map(activity => Number((activity.total_elevation_gain).toFixed(0)));
                const avgWatts = sortedActivities.map(activity => (typeof activity.average_watts === 'number') ? Math.round(activity.average_watts) : null);
                const pointColors = sortedActivities.map(a => a.sport_type === 'VirtualRide' ? '#1e88e5' : '#2e7d32');

                // Destroy previous charts if they exist
                try { window.speedPowerChart && window.speedPowerChart.destroy && window.speedPowerChart.destroy(); } catch (e) {}
                try { window.distanceElevationChart && window.distanceElevationChart.destroy && window.distanceElevationChart.destroy(); } catch (e) {}
                try { window.heartRateChart && window.heartRateChart.destroy && window.heartRateChart.destroy(); } catch (e) {}

        const ctx = document.getElementById('activitiesChart').getContext('2d');
            // eslint-disable-next-line no-unused-vars
        const activitiesChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                    datasets: [
                        {
                    label: 'Average Speed (km/h)',
                    data: data,
                    borderColor: 'rgb(75, 192, 192)',
                            pointBackgroundColor: pointColors,
                            pointBorderColor: pointColors,
                            tension: 0.1,
                            fill: false,
                            yAxisID: 'ySpeed'
                        },
                        {
                            label: 'Average Power (W)',
                            data: avgWatts,
                            borderColor: 'rgb(255, 159, 64)',
                            pointBackgroundColor: pointColors,
                            pointBorderColor: pointColors,
                    tension: 0.1,
                            fill: false,
                            yAxisID: 'yWatts'
                        }
                    ]
            },
            options: {
                responsive: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => {
                                    if (!items || !items.length) return '';
                                    const index = items[0].dataIndex;
                                    const act = sortedActivities[index];
                                    if (!act) return '';
                                    const name = act.name || '';
                                    const timeStr = formatMovingTime(act.moving_time);
                                    return timeStr ? `${name} | ${timeStr}` : name;
                                },
                                label: (item) => {
                                    if (item.dataset && item.dataset.label && item.dataset.label.includes('Power')) {
                                        return `Average Power: ${item.formattedValue} W`;
                                    }
                                    return `Average Speed: ${item.formattedValue} km/h`;
                                }
                            }
                        }
                    },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Start Date Local'
                        }
                    },
                        ySpeed: {
                            type: 'linear',
                            position: 'left',
                        title: {
                            display: true,
                            text: 'Average Speed (km/h)'
                        },
                        beginAtZero: true
                        },
                        yWatts: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Average Power (W)'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            beginAtZero: true
                        }
                    }
                }
            });

        // Click-to-open activity on speed/power chart
        activitiesChart.options.onClick = (evt) => {
            const points = activitiesChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
            if (!points || !points.length) return;
            const index = points[0].index;
            const activity = sortedActivities[index];
            if (activity && activity.id) {
                window.open(`https://www.strava.com/activities/${activity.id}/analysis`, '_blank');
            }
        };
        activitiesChart.update();

            // Build toggles for activitiesChart datasets
            buildLegendToggles('speedPowerControls', activitiesChart);
            window.speedPowerChart = activitiesChart;

                const distanceCtx = document.getElementById('distanceChart').getContext('2d');
            // eslint-disable-next-line no-unused-vars
                const distanceChart = new Chart(distanceCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Distance (km)',
                            data: distanceKm,
                            borderColor: 'rgb(54, 162, 235)',
                            pointBackgroundColor: pointColors,
                            pointBorderColor: pointColors,
                            tension: 0.1,
                            fill: false,
                            yAxisID: 'yDistance'
                        },
                        {
                            label: 'Elevation Gain (m)',
                            data: elevationM,
                            borderColor: 'rgb(255, 99, 132)',
                            pointBackgroundColor: pointColors,
                            pointBorderColor: pointColors,
                            tension: 0.1,
                            fill: false,
                            yAxisID: 'yElevation'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => {
                                    if (!items || !items.length) return '';
                                    const index = items[0].dataIndex;
                                    const act = sortedActivities[index];
                                    if (!act) return '';
                                    const name = act.name || '';
                                    const timeStr = formatMovingTime(act.moving_time);
                                    return timeStr ? `${name} | ${timeStr}` : name;
                                },
                                label: (item) => {
                                    if (item.dataset && item.dataset.label && item.dataset.label.includes('Elevation')) {
                                        return `Elevation Gain: ${item.formattedValue} m`;
                                    }
                                    return `Distance: ${item.formattedValue} km`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Start Date Local'
                            }
                        },
                        yDistance: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Distance (km)'
                            },
                            beginAtZero: true
                        },
                        yElevation: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Elevation Gain (m)'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            beginAtZero: true
                        }
                    }
                }
            });

        // Click-to-open activity on distance/elevation chart
        distanceChart.options.onClick = (evt) => {
            const points = distanceChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
            if (!points || !points.length) return;
            const index = points[0].index;
            const activity = sortedActivities[index];
            if (activity && activity.id) {
                window.open(`https://www.strava.com/activities/${activity.id}/analysis`, '_blank');
            }
        };
        distanceChart.update();

                // Rebuild dataset toggles after rendering
                buildLegendToggles('speedPowerControls', activitiesChart);
                buildLegendToggles('distanceElevationControls', distanceChart);
                window.distanceElevationChart = distanceChart;

                // Heart rate chart (average and max)
                const avgHr = sortedActivities.map(a => (typeof a.average_heartrate === 'number') ? Math.round(a.average_heartrate) : null);
                const maxHr = sortedActivities.map(a => (typeof a.max_heartrate === 'number') ? Math.round(a.max_heartrate) : null);
                const sufferScore = sortedActivities.map(a => (typeof a.suffer_score === 'number') ? Math.round(a.suffer_score) : null);
                const hrCtx = document.getElementById('heartRateChart').getContext('2d');
                const heartRateChart = new Chart(hrCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Average HR (bpm)',
                                data: avgHr,
                                borderColor: '#8e24aa',
                                pointBackgroundColor: pointColors,
                                pointBorderColor: pointColors,
                                tension: 0.1,
                                fill: false
                            },
                            {
                                label: 'Max HR (bpm)',
                                data: maxHr,
                                borderColor: '#d81b60',
                                pointBackgroundColor: pointColors,
                                pointBorderColor: pointColors,
                                tension: 0.1,
                                fill: false
                            },
                            {
                                label: 'Suffer Score',
                                data: sufferScore,
                                borderColor: '#ff9800',
                                pointBackgroundColor: pointColors,
                                pointBorderColor: pointColors,
                                tension: 0.1,
                                fill: false,
                                yAxisID: 'ySuffer'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    title: (items) => {
                                        if (!items || !items.length) return '';
                                        const index = items[0].dataIndex;
                                        const act = sortedActivities[index];
                                        if (!act) return '';
                                        const name = act.name || '';
                                        const timeStr = formatMovingTime(act.moving_time);
                                        return timeStr ? `${name} | ${timeStr}` : name;
                                    },
                                    label: (item) => {
                                        if (item.dataset && item.dataset.label && item.dataset.label.includes('Suffer')) {
                                            return `Suffer Score: ${item.formattedValue}`;
                                        }
                                        return `${item.dataset.label}: ${item.formattedValue} bpm`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Start Date Local' }
                            },
                            y: {
                                title: { display: true, text: 'Heart Rate (bpm)' },
                                beginAtZero: false
                            },
                            ySuffer: {
                                type: 'linear',
                                position: 'right',
                                title: { display: true, text: 'Suffer Score' },
                                grid: { drawOnChartArea: false },
                                beginAtZero: true
                            }
                        }
                    }
                });

                // Click-to-open for heart rate chart
                heartRateChart.options.onClick = (evt) => {
                    const points = heartRateChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                    if (!points || !points.length) return;
                    const index = points[0].index;
                    const activity = sortedActivities[index];
                    if (activity && activity.id) {
                        window.open(`https://www.strava.com/activities/${activity.id}/analysis`, '_blank');
                    }
                };
                heartRateChart.update();
                window.heartRateChart = heartRateChart;
                buildLegendToggles('heartRateControls', heartRateChart);

                // Location table - count activities by timezone and group polylines
                // Separate VirtualRide activities into "Virtual" category
                const locationData = {};
                sortedActivities.forEach(a => {
                    // Check if it's a VirtualRide
                    if (a.sport_type === 'VirtualRide') {
                        const location = 'Virtual';
                        if (!locationData[location]) {
                            locationData[location] = {
                                count: 0,
                                polylines: []
                            };
                        }
                        locationData[location].count++;
                        // Virtual rides typically don't have real polylines, but include if they do
                        if (a.map && a.map.summary_polyline) {
                            locationData[location].polylines.push(a.map.summary_polyline);
                        }
                    } else {
                        const formattedLocation = formatTimezone(a.timezone);
                        if (!locationData[formattedLocation]) {
                            locationData[formattedLocation] = {
                                count: 0,
                                polylines: []
                            };
                        }
                        locationData[formattedLocation].count++;
                        if (a.map && a.map.summary_polyline) {
                            locationData[formattedLocation].polylines.push(a.map.summary_polyline);
                        }
                    }
                });
                
                // Sort by count (descending)
                const sortedLocations = Object.entries(locationData)
                    .sort((a, b) => b[1].count - a[1].count);
                
                // Generate table HTML with map column
                const locationContainer = document.getElementById('locationChart');
                let tableHTML = '<div class="location-table-title">Ride locations</div>';
                tableHTML += '<table class="location-table">';
                tableHTML += '<thead><tr><th>Location</th><th>Activities</th><th>Map</th></tr></thead>';
                tableHTML += '<tbody>';
                sortedLocations.forEach(([location, data]) => {
                    const mapId = `map-${location.replace(/\s+/g, '-').toLowerCase()}`;
                    tableHTML += `<tr><td>${location}</td><td>${data.count}</td><td class="location-map-cell"><div id="${mapId}"></div></td></tr>`;
                });
                tableHTML += '</tbody></table>';
                locationContainer.innerHTML = tableHTML;
                
                // Render maps after a brief delay to ensure DOM is ready
                setTimeout(() => {
                    sortedLocations.forEach(([location, data]) => {
                        if (data.polylines.length > 0) {
                            const mapId = `map-${location.replace(/\s+/g, '-').toLowerCase()}`;
                            renderTimezoneMap(mapId, data.polylines);
                        }
                    });

                    // Attach row click handlers to open interactive modal map
                    const tbodyRows = document.querySelectorAll('#locationChart tbody tr');
                    tbodyRows.forEach((row) => {
                        row.addEventListener('click', () => {
                            const location = row.children[0] ? row.children[0].textContent : '';
                            const entry = sortedLocations.find(([loc]) => loc === location);
                            const polylines = entry ? entry[1].polylines : [];
                            showModalMap(location, polylines);
                        });
                    });
                }, 100);
            }

            // Helper to decode Google polyline to coordinates
            function decodePolyline(str) {
                const coords = [];
                let index = 0;
                let lat = 0;
                let lng = 0;
                
                while (index < str.length) {
                    let b, shift = 0, result = 0;
                    do {
                        b = str.charCodeAt(index++) - 63;
                        result |= (b & 0x1f) << shift;
                        shift += 5;
                    } while (b >= 0x20);
                    const dLat = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
                    lat += dLat;
                    
                    shift = 0;
                    result = 0;
                    do {
                        b = str.charCodeAt(index++) - 63;
                        result |= (b & 0x1f) << shift;
                        shift += 5;
                    } while (b >= 0x20);
                    const dLng = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
                    lng += dLng;
                    
                    coords.push([lat * 1e-5, lng * 1e-5]);
                }
                
                return coords;
            }

            // Helper to render a mini map for a timezone with all its polylines
            function renderTimezoneMap(containerId, polylines) {
                if (!polylines || polylines.length === 0) return;
                
                try {
                    // Decode all polylines and collect coordinates
                    const allCoordinates = [];
                    polylines.forEach(polylineStr => {
                        try {
                            const decoded = decodePolyline(polylineStr);
                            // decoded returns [lat, lng] pairs
                            decoded.forEach(coord => {
                                allCoordinates.push(coord);
                            });
                        } catch (e) {
                            console.warn('Failed to decode polyline:', e);
                        }
                    });
                    
                    if (allCoordinates.length === 0) return;
                    
                    // Create the map
                    const map = L.map(containerId, {
                        zoomControl: false,
                        attributionControl: false,
                        scrollWheelZoom: false,
                        dragging: false,
                        touchZoom: false,
                        doubleClickZoom: false,
                        boxZoom: false,
                        keyboard: false
                    });
                    
                    // Add tile layer
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        minZoom: 3,
                        maxZoom: 15
                    }).addTo(map);
                    
                    // Draw all routes as polylines
                    polylines.forEach((polylineStr, idx) => {
                        try {
                            const decoded = decodePolyline(polylineStr);
                            if (decoded && decoded.length > 0) {
                                // Create polyline with different colors for each route
                                const colors = ['#fc4c02', '#1e88e5', '#2e7d32', '#8e24aa', '#ff9800'];
                                const color = colors[idx % colors.length];
                                
                                L.polyline(decoded, {
                                    color: color,
                                    weight: 2,
                                    opacity: 0.7
                                }).addTo(map);
                            }
                        } catch (e) {
                            console.warn('Failed to process polyline:', e);
                        }
                    });
                    
                    // Fit bounds to show all routes
                    if (allCoordinates.length > 0) {
                        const bounds = L.latLngBounds(allCoordinates);
                        map.fitBounds(bounds, { padding: [5, 5] });
                    }
                } catch (error) {
                    console.error('Error rendering map:', error);
                }
            }

            // Open modal with interactive Leaflet map for a location
            function showModalMap(location, polylines) {
                const modal = document.getElementById('mapModal');
                const modalHeader = document.getElementById('modalMapHeader');
                const modalMap = document.getElementById('modalMap');
                const closeBtn = document.querySelector('.map-modal-close');

                modalHeader.textContent = `${location} - ${polylines.length} route${polylines.length === 1 ? '' : 's'}`;
                modal.style.display = 'flex';
                modal.setAttribute('aria-hidden', 'false');

                // Reset map container
                modalMap.innerHTML = '';
                const map = L.map('modalMap');
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(map);

                const allCoords = [];
                polylines.forEach((polylineStr, idx) => {
                    const decoded = decodePolyline(polylineStr);
                    decoded.forEach(c => allCoords.push(c));
                    const colors = ['#fc4c02', '#1e88e5', '#2e7d32', '#8e24aa', '#ff9800'];
                    const color = colors[idx % colors.length];
                    L.polyline(decoded, { color, weight: 3, opacity: 0.85 }).addTo(map);
                });
                if (allCoords.length) {
                    const bounds = L.latLngBounds(allCoords);
                    map.fitBounds(bounds, { padding: [15, 15] });
                }

                function closeModal() {
                    modal.style.display = 'none';
                    modal.setAttribute('aria-hidden', 'true');
                    map.remove();
                    document.removeEventListener('keydown', onEsc);
                }
                function onEsc(e) { if (e.key === 'Escape') closeModal(); }
                closeBtn.onclick = closeModal;
                modal.onclick = (e) => { if (e.target === modal) closeModal(); };
                document.addEventListener('keydown', onEsc);
            }

            // Helper to render checkbox toggles that control dataset visibility
            function buildLegendToggles(containerId, chartInstance) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                if (!chartInstance || !chartInstance.data || !Array.isArray(chartInstance.data.datasets)) {
                    return;
                }
                chartInstance.data.datasets.forEach((ds, idx) => {
                    const label = document.createElement('label');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = chartInstance.isDatasetVisible(idx);
                    checkbox.addEventListener('change', () => {
                        chartInstance.setDatasetVisibility(idx, checkbox.checked);
                        chartInstance.update();
                    });
                    const swatch = document.createElement('span');
                    swatch.className = 'legend-swatch';
                    swatch.style.backgroundColor = ds.borderColor || '#666';
                    const text = document.createElement('span');
                    text.textContent = ds.label || `Series ${idx + 1}`;
                    label.appendChild(checkbox);
                    label.appendChild(swatch);
                    label.appendChild(text);
                    container.appendChild(label);
                });
            }
        }

        const fileInputEl = document.getElementById('jsonFileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const callApiBtn = document.getElementById('callApiBtn');
        const comingSoonEl = document.getElementById('comingSoon');

        uploadBtn.addEventListener('click', () => {
            // Reset value so selecting the same file again still triggers change
            fileInputEl.value = '';
            fileInputEl.click();
        });
        fileInputEl.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                let activities;
                try {
                    activities = parseActivities(reader.result);
                } catch (err) {
                    console.error(err);
                    alert(`Failed to parse JSON file: ${err.message}`);
                    return;
                }
                try {
                    // Ensure charts UI is visible if previously hidden by "Call Strava API"
                    showChartsUI();
                    renderChart(activities);
                } catch (err) {
                    console.error(err);
                    alert(`Failed to load data into charts: ${err.message}`);
                }
                // Reset the input so the same file can be selected again later
                fileInputEl.value = '';
            };
            reader.readAsText(file);
        });

        // Call Strava API functionality
        callApiBtn.addEventListener('click', async () => {
            const numActivitiesInput = document.getElementById('numActivities');
            const authTokenInput = document.getElementById('authToken');
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('errorMessage');
            
            // Get values from inputs
            const numActivities = parseInt(numActivitiesInput.value, 10);
            const authToken = authTokenInput.value.trim();
            
            // Validate inputs
            if (isNaN(numActivities) || numActivities < 1) {
                errorEl.textContent = 'Please enter a valid number of activities (minimum 1)';
                errorEl.style.display = 'block';
                return;
            }
            
            if (!authToken) {
                errorEl.textContent = 'Please enter an authorization token';
                errorEl.style.display = 'block';
                return;
            }
            
            // Hide error message and show loading
            errorEl.style.display = 'none';
            loadingEl.style.display = 'inline';
            callApiBtn.disabled = true;
            
            try {
                // Calculate pagination: Strava API max is 200 per page
                const MAX_PER_PAGE = 200;
                const totalRequested = numActivities;
                const allActivities = [];
                
                // Calculate how many pages we need
                const totalPages = Math.ceil(totalRequested / MAX_PER_PAGE);
                
                // Make multiple API calls if needed
                for (let page = 1; page <= totalPages; page++) {
                    // Calculate how many activities to request on this page
                    const remaining = totalRequested - allActivities.length;
                    const perPage = Math.min(remaining, MAX_PER_PAGE);
                    
                    // Make API call for this page
                    const url = `https://www.strava.com/api/v3/athlete/activities?per_page=${perPage}&page=${page}`;
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json',
                            'authorization': `Bearer ${authToken}`
                        }
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API request failed on page ${page}: ${response.status} ${response.statusText}. ${errorText}`);
                    }
                    
                    const pageActivities = await response.json();
                    
                    if (!Array.isArray(pageActivities)) {
                        throw new Error(`API response on page ${page} is not an array of activities`);
                    }
                    
                    // If we got fewer activities than requested, we've reached the end
                    if (pageActivities.length === 0) {
                        break;
                    }
                    
                    // Add activities from this page to our collection
                    allActivities.push(...pageActivities);
                    
                    // If we've got enough activities or got fewer than requested, we're done
                    if (allActivities.length >= totalRequested || pageActivities.length < perPage) {
                        break;
                    }
                }
                
                // Trim to exactly the requested number (in case we got a few extra)
                const finalActivities = allActivities.slice(0, totalRequested);
                
                if (finalActivities.length === 0) {
                    throw new Error('No activities found');
                }
                
                // Show charts UI and render the data
                showChartsUI();
                renderChart(finalActivities);
                
            } catch (err) {
                console.error('Error calling Strava API:', err);
                errorEl.textContent = `Error: ${err.message}`;
                errorEl.style.display = 'block';
            } finally {
                loadingEl.style.display = 'none';
                callApiBtn.disabled = false;
            }
        });

        // OAuth functionality
        const oauthBtn = document.getElementById('oauthBtn');
        const oauthLoadingEl = document.getElementById('oauthLoading');
        const errorEl = document.getElementById('errorMessage');

        // Application credentials (do NOT expose these in a public repo)
        const STRAVA_CLIENT_ID = '179304';
        const STRAVA_CLIENT_SECRET = '1b74420217e1353bfe6bc138f96d7fb7cc9cb7e5';

        // Check if we're returning from OAuth callback
        function handleOAuthCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const error = urlParams.get('error');
            
            if (error) {
                errorEl.textContent = `OAuth error: ${error}`;
                errorEl.style.display = 'block';
                // Clean up URL
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }
            
            if (code) {
                // Exchange code for access token
                exchangeCodeForToken(code);
                // Clean up URL
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }

        // Exchange authorization code for access token
        async function exchangeCodeForToken(code) {
            oauthLoadingEl.style.display = 'inline';
            oauthBtn.disabled = true;
            errorEl.style.display = 'none';
            
            try {
                // Exchange code for access token
                const tokenResponse = await fetch('https://www.strava.com/api/v3/oauth/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: STRAVA_CLIENT_ID,
                        client_secret: STRAVA_CLIENT_SECRET,
                        code: code,
                        grant_type: 'authorization_code'
                    })
                });
                
                if (!tokenResponse.ok) {
                    const errorText = await tokenResponse.text();
                    throw new Error(`Token exchange failed: ${tokenResponse.status} ${tokenResponse.statusText}. ${errorText}`);
                }
                
                const tokenData = await tokenResponse.json();
                
                if (!tokenData.access_token) {
                    throw new Error('No access token received from Strava');
                }
                
                // Store tokens and client credentials in localStorage
                localStorage.setItem('strava_access_token', tokenData.access_token);
                if (tokenData.refresh_token) {
                    localStorage.setItem('strava_refresh_token', tokenData.refresh_token);
                }
                if (tokenData.expires_at) {
                    localStorage.setItem('strava_token_expires_at', tokenData.expires_at.toString());
                }
                
                // Use the access token to fetch activities
                const numActivities = parseInt(document.getElementById('numActivities').value, 10) || 200;
                await fetchActivitiesWithToken(tokenData.access_token, numActivities);
                
            } catch (err) {
                console.error('Error exchanging OAuth code:', err);
                errorEl.textContent = `Error: ${err.message}`;
                errorEl.style.display = 'block';
            } finally {
                oauthLoadingEl.style.display = 'none';
                oauthBtn.disabled = false;
            }
        }

        // Fetch activities using access token (with pagination support)
        async function fetchActivitiesWithToken(accessToken, numActivities = 200) {
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'inline';
            errorEl.style.display = 'none';
            
            try {
                const MAX_PER_PAGE = 200;
                const totalRequested = numActivities;
                const allActivities = [];
                
                const totalPages = Math.ceil(totalRequested / MAX_PER_PAGE);
                
                for (let page = 1; page <= totalPages; page++) {
                    const remaining = totalRequested - allActivities.length;
                    const perPage = Math.min(remaining, MAX_PER_PAGE);
                    
                    const url = `https://www.strava.com/api/v3/athlete/activities?per_page=${perPage}&page=${page}`;
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json',
                            'authorization': `Bearer ${accessToken}`
                        }
                    });
                    
                    if (!response.ok) {
                        // If token expired, try to refresh
                        if (response.status === 401) {
                            const refreshedToken = await refreshAccessToken();
                            if (refreshedToken) {
                                // Retry with new token
                                const retryResponse = await fetch(url, {
                                    method: 'GET',
                                    headers: {
                                        'accept': 'application/json',
                                        'authorization': `Bearer ${refreshedToken}`
                                    }
                                });
                                if (!retryResponse.ok) {
                                    const errorText = await retryResponse.text();
                                    throw new Error(`API request failed on page ${page}: ${retryResponse.status} ${retryResponse.statusText}. ${errorText}`);
                                }
                                const pageActivities = await retryResponse.json();
                                if (!Array.isArray(pageActivities)) {
                                    throw new Error(`API response on page ${page} is not an array of activities`);
                                }
                                if (pageActivities.length === 0) break;
                                allActivities.push(...pageActivities);
                                if (allActivities.length >= totalRequested || pageActivities.length < perPage) break;
                                continue;
                            }
                        }
                        const errorText = await response.text();
                        throw new Error(`API request failed on page ${page}: ${response.status} ${response.statusText}. ${errorText}`);
                    }
                    
                    const pageActivities = await response.json();
                    
                    if (!Array.isArray(pageActivities)) {
                        throw new Error(`API response on page ${page} is not an array of activities`);
                    }
                    
                    if (pageActivities.length === 0) {
                        break;
                    }
                    
                    allActivities.push(...pageActivities);
                    
                    if (allActivities.length >= totalRequested || pageActivities.length < perPage) {
                        break;
                    }
                }
                
                const finalActivities = allActivities.slice(0, totalRequested);
                
                if (finalActivities.length === 0) {
                    throw new Error('No activities found');
                }
                
                showChartsUI();
                renderChart(finalActivities);
                
            } catch (err) {
                console.error('Error fetching activities:', err);
                errorEl.textContent = `Error: ${err.message}`;
                errorEl.style.display = 'block';
            } finally {
                loadingEl.style.display = 'none';
            }
        }

        // Refresh expired access token
        async function refreshAccessToken() {
            const refreshToken = localStorage.getItem('strava_refresh_token');
            
            if (!refreshToken) {
                return null;
            }
            
            try {
                const response = await fetch('https://www.strava.com/api/v3/oauth/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: STRAVA_CLIENT_ID,
                        client_secret: STRAVA_CLIENT_SECRET,
                        grant_type: 'refresh_token',
                        refresh_token: refreshToken
                    })
                });
                
                if (!response.ok) {
                    return null;
                }
                
                const tokenData = await response.json();
                
                if (tokenData.access_token) {
                    localStorage.setItem('strava_access_token', tokenData.access_token);
                    if (tokenData.refresh_token) {
                        localStorage.setItem('strava_refresh_token', tokenData.refresh_token);
                    }
                    if (tokenData.expires_at) {
                        localStorage.setItem('strava_token_expires_at', tokenData.expires_at.toString());
                    }
                    return tokenData.access_token;
                }
                
                return null;
            } catch (err) {
                console.error('Error refreshing token:', err);
                return null;
            }
        }

        // OAuth button click handler
        oauthBtn.addEventListener('click', () => {
            // Build redirect URI (current page)
            const redirectUri = window.location.origin + window.location.pathname;
            
            // Redirect to Strava authorization page
            const authUrl = new URL('https://www.strava.com/oauth/authorize');
            authUrl.searchParams.set('client_id', STRAVA_CLIENT_ID);
            authUrl.searchParams.set('redirect_uri', redirectUri);
            authUrl.searchParams.set('response_type', 'code');
            authUrl.searchParams.set('approval_prompt', 'auto');
            authUrl.searchParams.set('scope', 'activity:read_all');
            
            window.location.href = authUrl.toString();
        });

        // Use stored token button
        const useStoredTokenBtn = document.getElementById('useStoredTokenBtn');
        useStoredTokenBtn.addEventListener('click', async () => {
            const storedToken = localStorage.getItem('strava_access_token');
            const expiresAt = localStorage.getItem('strava_token_expires_at');
            
            if (!storedToken) {
                errorEl.textContent = 'No stored token found. Please connect with Strava first.';
                errorEl.style.display = 'block';
                return;
            }
            
            // Check if token is expired (with 5 minute buffer)
            const now = Math.floor(Date.now() / 1000);
            const expiresAtNum = parseInt(expiresAt, 10);
            if (expiresAtNum && now >= expiresAtNum - 300) {
                // Token expired or expiring soon, try to refresh
                oauthLoadingEl.style.display = 'inline';
                useStoredTokenBtn.disabled = true;
                try {
                    const refreshedToken = await refreshAccessToken();
                    if (refreshedToken) {
                        await fetchActivitiesWithToken(refreshedToken, parseInt(document.getElementById('numActivities').value, 10) || 200);
                    } else {
                        errorEl.textContent = 'Token expired and could not be refreshed. Please reconnect with Strava.';
                        errorEl.style.display = 'block';
                    }
                } finally {
                    oauthLoadingEl.style.display = 'none';
                    useStoredTokenBtn.disabled = false;
                }
            } else {
                // Token is still valid
                await fetchActivitiesWithToken(storedToken, parseInt(document.getElementById('numActivities').value, 10) || 200);
            }
        });

        // Check for OAuth callback on page load
        handleOAuthCallback();

        // Load stored token state on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Show/hide "Use Stored Token" button based on whether token exists
            const storedToken = localStorage.getItem('strava_access_token');
            if (storedToken) {
                useStoredTokenBtn.style.display = 'inline-block';
            } else {
                useStoredTokenBtn.style.display = 'none';
            }
        });

        function showChartsUI() {
            const sections = [
                'sportControls', 'activitiesChart', 'speedPowerControls',
                'distanceChart', 'distanceElevationControls',
                'heartRateChart', 'heartRateControls', 'locationChart'
            ];
            sections.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = '';
            });
            comingSoonEl.style.display = 'none';
            comingSoonEl.setAttribute('aria-hidden', 'true');
        }

        function parseActivities(rawText) {
            // Strip BOM and trim
            let text = rawText.replace(/^\uFEFF/, '').trim();
            // Try plain JSON array
            try {
                const parsed = JSON.parse(text);
                if (Array.isArray(parsed)) return parsed;
                if (parsed && Array.isArray(parsed.activities)) return parsed.activities;
                if (parsed && Array.isArray(parsed.data)) return parsed.data;
                throw new Error('Top-level JSON is not an array of activities.');
            } catch (_) {
                // Fallback: NDJSON (one JSON object per line)
                const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
                if (lines.length > 1) {
                    const items = [];
                    for (const line of lines) {
                        try {
                            const obj = JSON.parse(line);
                            items.push(obj);
                        } catch (e) {
                            // If any line fails, abort NDJSON path
                            throw new Error('Invalid JSON format (not array or NDJSON).');
                        }
                    }
                    return items;
                }
                // If single-line and failed, rethrow generic error
                throw new Error('Invalid JSON format. Expected array of activities.');
            }
        }
    </script>
</body>
</html>
